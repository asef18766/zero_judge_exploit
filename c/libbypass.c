#define _GNU_SOURCE
#include <link.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <fnmatch.h>
#include <dlfcn.h>
#include <stdbool.h>
#include <execinfo.h>

void (*shell)(char *cmd) = NULL;

#pragma region magic

#include <limits.h>
#define UINTS_PER_WORD (__WORDSIZE / (CHAR_BIT * sizeof(unsigned int)))

static ElfW(Word) gnu_hashtab_symbol_count(const unsigned int *const table)
{
    const unsigned int *const bucket = table + 4 + table[2] * (unsigned int)(UINTS_PER_WORD);
    unsigned int b = table[0];
    unsigned int max = 0U;

    while (b-- > 0U)
        if (bucket[b] > max)
            max = bucket[b];

    return (ElfW(Word))max;
}
#pragma endregion

bool check_address_in_segment(Elf64_Addr addr, Elf64_Addr upper_bound[], Elf64_Addr lower_bound[], int bound_count)
{
    for (int i = 0; i != bound_count; i++)
    {
        if (addr >= lower_bound[i] &&
            addr < upper_bound[i])
            return true;
    }
    return false;
}
int get_code_segment_bounds(
    Elf64_Addr base,
    const Elf64_Phdr *header,
    Elf64_Half header_count,
    Elf64_Addr upper_bound[],
    Elf64_Addr lower_bound[])
{
    int bound_cnt = 0;
    for (int h = 0; h < header_count; h++)
    {
        Elf64_Addr segment = base + header[h].p_vaddr;

        if (header[h].p_type == PT_LOAD)
        {
            lower_bound[bound_cnt] = segment;
            upper_bound[bound_cnt] = segment + header[h].p_memsz;
            bound_cnt++;
        }
    }
    return bound_cnt;
}
void parse_module(struct dl_phdr_info *info)
{
    char *type;
    int p_type, j;

    Elf64_Addr upper_bound[0x87];
    Elf64_Addr lower_bound[0x87];
    int bound_cnt = get_code_segment_bounds(info->dlpi_addr, info->dlpi_phdr, info->dlpi_phnum, upper_bound, lower_bound);
    Elf64_Sym *symbol_table = NULL;
    Elf64_Word symbol_count = 0;
    char *string_table = NULL;

    for (j = 0; j != info->dlpi_phnum; j++)
    {
        // find dynamic segment
        if (info->dlpi_phdr[j].p_type == PT_DYNAMIC)
        {
            Elf64_Dyn *entry = (Elf64_Dyn *)(info->dlpi_addr + info->dlpi_phdr[j].p_vaddr);
            // find the symbol table & string table section
            for (; entry->d_tag != DT_NULL; entry++)
            {
                switch (entry->d_tag)
                {
                case DT_HASH:
                    if (check_address_in_segment(entry->d_un.d_ptr, upper_bound, lower_bound, bound_cnt))
                    {
                        symbol_count = ((Elf64_Word *)(entry->d_un.d_ptr))[1];
                    }
                    break;
                case DT_GNU_HASH:
                    if (check_address_in_segment(entry->d_un.d_ptr, upper_bound, lower_bound, bound_cnt))
                    {
                        ElfW(Word) count = gnu_hashtab_symbol_count((unsigned int *const)(entry->d_un.d_ptr));
                        if (count > symbol_count)
                            symbol_count = count;
                    }
                    break;
                case DT_STRTAB:
                    if (check_address_in_segment(entry->d_un.d_ptr, upper_bound, lower_bound, bound_cnt))
                    {
                        string_table = (char *)entry->d_un.d_ptr;
                    }
                    break;
                case DT_SYMTAB:
                    if (check_address_in_segment(entry->d_un.d_ptr, upper_bound, lower_bound, bound_cnt))
                    {
                        symbol_table = (Elf64_Sym *)entry->d_un.d_ptr;
                    }
                    break;
                }
            }
        }
    }
    // get function address
    if (symbol_table && string_table && symbol_count > 0)
    {
        for (int i = 0; i != symbol_count ; i++)
        {
            Elf64_Addr func_addr = info->dlpi_addr + symbol_table[i].st_value;
            if (!check_address_in_segment(func_addr, upper_bound, lower_bound, bound_cnt))
                continue;
            
            // we only care about function here
            if (ELF64_ST_TYPE(symbol_table[i].st_info) != STT_FUNC)
                continue;
            
            char *func_name = symbol_table[i].st_name + string_table;

            // i am too lazy to design an general method
            if (strcmp("system", func_name) == 0)
            {
                //printf("found system\n");
                shell = (void (*)(char *))func_addr;
                break;
            }
        }
    }
    else
    {
        printf("[error] Can not obtain symbol infomations !!\n");
    }
}
static int
callback(struct dl_phdr_info *info, size_t size, void *data)
{
    char target[] = "libc.so";
    if (strstr(info->dlpi_name, target) != NULL)
    {
        parse_module(info);
    }
    return 0;
}

int main(int argc, char *argv[], char *envp[])
{
    dl_iterate_phdr(callback, NULL);
    if (shell == NULL)
    {
        puts("[error]");
        return -1;
    }
    shell("whoami");
}